<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Arrays</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html,4,png,sections+ --> 
<meta name="src" content="ref.tex"> 
<meta name="date" content="2008-08-23 11:42:00"> 
<link rel="stylesheet" type="text/css" href="ref.css"> 
</head><body 
>
<!--l. 1330--><div class="crosslinks"><p class="noindent">[<a 
href="refsu15.html" >next</a>] [<a 
href="#tailrefsu14.html">tail</a>] [<a 
href="refse14.html#refsu14.html" >up</a>] </p></div>
<h4 class="subsectionHead"><span class="titlemark">3.3.1   </span> <a 
href="ref.html#QQ2-37-46" id="x37-410003.3.1">Arrays</a></h4>
<a 
 id="dx37-41001"></a>
<a 
 id="dx37-41002"></a>
<!--l. 1332--><p class="noindent" >Free Pascal supports arrays as in Turbo Pascal. Multi-dimensional arrays and (bit)packed arrays
are also supported, as well as the dynamic arrays of Delphi:
     <div class="quote">
     <!--l. 1--><p class="noindent" >_________________________________________________________________________________________________________<span 
class="cmbx-10">Array types</span><BR/><img 
src="ref38x.png" alt="--        --------------    -----------------------   -    ------
  array type --      --| array  - ---          --  -| of  type
            -bpitapcakecdked -|        [  -ordina,l type-|]
     " ><BR/>
     ___________________________________________________________________</div>
<!--l. 1336--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
href="refse14.html#QQ2-37-47" id="x37-420003.3.1">Static arrays</a></h5>
<a 
 id="dx37-42001"></a>
<a 
 id="dx37-42002"></a>
<!--l. 1337--><p class="noindent" ><a name="keyword:array"></a> When the range of the array is included in the array definition, it is called a static array. Trying
to access an element with an index that is outside the declared range will generate a
run-time error (if range checking is on). The following is an example of a valid array
declaration:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Type
&#x00A0;<br />&#x00A0;&#x00A0;RealArray&#x00A0;=&#x00A0;Array&#x00A0;[1..100]&#x00A0;of&#x00A0;Real;
</div>
</td></tr></table>
<!--l. 1345--><p class="nopar" >Valid indexes for accessing an element of the array are between 1 and 100, where the borders 1 and
100 are included. As in Turbo Pascal, if the array component type is in itself an array, it is
possible to combine the two arrays into one multi-dimensional array. The following
declaration:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Type
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;APoints&#x00A0;=&#x00A0;array[1..100]&#x00A0;of&#x00A0;Array[1..3]&#x00A0;of&#x00A0;Real;
</div>
</td></tr></table>
<!--l. 1354--><p class="nopar" >is equivalent to the declaration:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Type
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;APoints&#x00A0;=&#x00A0;array[1..100,1..3]&#x00A0;of&#x00A0;Real;
</div>
</td></tr></table>
<!--l. 1359--><p class="nopar" >The functions <span 
class="cmtt-10">High </span>and <span 
class="cmtt-10">Low </span>return the high and low bounds of the leftmost index type of the
array. In the above case, this would be 100 and 1. You should use them whenever possible, since it
improves maintainability of your code. The use of both functions is just as efficient as using
constants, because they are evaluated at compile time.
<!--l. 1366--><p class="noindent" >When static array-type variables are assigned to each other, the contents of the whole array is
copied. This is also true for multi-dimensional arrays:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
program&#x00A0;testarray1;
&#x00A0;<br />
&#x00A0;<br />Type
&#x00A0;<br />&#x00A0;&#x00A0;TA&#x00A0;=&#x00A0;Array[0..9,0..9]&#x00A0;of&#x00A0;Integer;
&#x00A0;<br />
&#x00A0;<br />var
&#x00A0;<br />&#x00A0;&#x00A0;A,B&#x00A0;:&#x00A0;TA;
&#x00A0;<br />&#x00A0;&#x00A0;I,J&#x00A0;:&#x00A0;Integer;
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;A[I,J]:=I*J;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Write(A[I,J]:2,&#8217;&#x00A0;&#8217;);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />&#x00A0;&#x00A0;B:=A;
&#x00A0;<br />&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;A[9-I,9-J]:=I*J;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Write(B[I,J]:2,&#8217;&#x00A0;&#8217;);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />end.
</div>
</td></tr></table>
<!--l. 1399--><p class="nopar" >The output of this program will be 2 identical matrices.
<!--l. 1402--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
href="refse14.html#QQ2-37-48" id="x37-430003.3.1">Dynamic arrays</a></h5>
<a 
 id="dx37-43001"></a>
<a 
 id="dx37-43002"></a>
<a 
 id="dx37-43003"></a>
<!--l. 1404--><p class="noindent" >As of version 1.1, Free Pascal also knows dynamic arrays: In that case the array range is omitted,
as in the following example:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Type
&#x00A0;<br />&#x00A0;&#x00A0;TByteArray&#x00A0;:&#x00A0;Array&#x00A0;of&#x00A0;Byte;
</div>
</td></tr></table>
<!--l. 1409--><p class="nopar" >When declaring a variable of a dynamic array type, the initial length of the array is zero. The
actual length of the array must be set with the standard <span 
class="cmtt-10">SetLength </span>function, which will allocate
the necessary memory to contain the array elements on the heap. The following example will set
the length to 1000:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Var
&#x00A0;<br />&#x00A0;&#x00A0;A&#x00A0;:&#x00A0;TByteArray;
&#x00A0;<br />
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;SetLength(A,1000);
</div>
</td></tr></table>
<!--l. 1421--><p class="nopar" >After a call to <span 
class="cmtt-10">SetLength</span>, valid array indexes are 0 to 999: the array index is always
zero-based.
<!--l. 1425--><p class="noindent" >Note that the length of the array is set in elements, not in bytes of allocated memory (although
these may be the same). The amount of memory allocated is the size of the array multiplied by the
size of 1 element in the array. The memory will be disposed of at the exit of the current procedure
or function.
<!--l. 1431--><p class="noindent" >It is also possible to resize the array: in that case, as much of the elements in the array as will fit in
the new size, will be kept. The array can be resized to zero, which effectively resets the
variable.
<!--l. 1435--><p class="noindent" >At all times, trying to access an element of the array with an index that is not in the current
length of the array will generate a run-time error.
<!--l. 1439--><p class="noindent" >Dynamic arrays are reference counted: assignment of one dynamic array-type variable to another
will let both variables point to the same array. Contrary to ansistrings, an assignment to an
element of one array will be reflected in the other: there is no copy-on-write. Consider the following
example:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Var
&#x00A0;<br />&#x00A0;&#x00A0;A,B&#x00A0;:&#x00A0;TByteArray;
&#x00A0;<br />
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;SetLength(A,10);
&#x00A0;<br />&#x00A0;&#x00A0;A[0]:=33;
&#x00A0;<br />&#x00A0;&#x00A0;B:=A;
&#x00A0;<br />&#x00A0;&#x00A0;A[0]:=31;
</div>
</td></tr></table>
<!--l. 1453--><p class="nopar" >After the second assignment, the first element in B will also contain 31.
<!--l. 1456--><p class="noindent" >It can also be seen from the output of the following example:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
program&#x00A0;testarray1;
&#x00A0;<br />
&#x00A0;<br />Type
&#x00A0;<br />&#x00A0;&#x00A0;TA&#x00A0;=&#x00A0;Array&#x00A0;of&#x00A0;array&#x00A0;of&#x00A0;Integer;
&#x00A0;<br />
&#x00A0;<br />var
&#x00A0;<br />&#x00A0;&#x00A0;A,B&#x00A0;:&#x00A0;TA;
&#x00A0;<br />&#x00A0;&#x00A0;I,J&#x00A0;:&#x00A0;Integer;
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;Setlength(A,10,10);
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;A[I,J]:=I*J;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Write(A[I,J]:2,&#8217;&#x00A0;&#8217;);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />&#x00A0;&#x00A0;B:=A;
&#x00A0;<br />&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;A[9-I,9-J]:=I*J;
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;begin
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;For&#x00A0;J:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Write(B[I,J]:2,&#8217;&#x00A0;&#8217;);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Writeln;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;end;
&#x00A0;<br />end.
</div>
</td></tr></table>
<!--l. 1489--><p class="nopar" >The output of this program will be a matrix of numbers, and then the same matrix,
mirrorred.
<a 
 id="dx37-43004"></a>
<!--l. 1493--><p class="noindent" >As remarked earlier, dynamic arrays are reference counted: if in one of the previous examples A
goes out of <a 
 id="dx37-43005"></a>scope and B does not, then the array is not yet disposed of: the reference count of A
(and B) is decreased with 1. As soon as the reference count reaches zero the memory, allocated for
the contents of the array, is disposed of.
<!--l. 1498--><p class="noindent" >It is also possible to copy and/or resize the array with the standard <span 
class="cmtt-10">Copy </span>function, which acts as
the copy function for strings:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
program&#x00A0;testarray3;
&#x00A0;<br />
&#x00A0;<br />Type
&#x00A0;<br />&#x00A0;&#x00A0;TA&#x00A0;=&#x00A0;array&#x00A0;of&#x00A0;Integer;
&#x00A0;<br />
&#x00A0;<br />var
&#x00A0;<br />&#x00A0;&#x00A0;A,B&#x00A0;:&#x00A0;TA;
&#x00A0;<br />&#x00A0;&#x00A0;I&#x00A0;:&#x00A0;Integer;
&#x00A0;<br />
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;Setlength(A,10);
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;9&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;A[I]:=I;
&#x00A0;<br />&#x00A0;&#x00A0;B:=Copy(A,3,6);
&#x00A0;<br />&#x00A0;&#x00A0;For&#x00A0;I:=0&#x00A0;to&#x00A0;5&#x00A0;do
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;Writeln(B[I]);
&#x00A0;<br />end.
</div>
</td></tr></table>
<!--l. 1518--><p class="nopar" >The <span 
class="cmtt-10">Copy </span>function will copy 6 elements of the array to a new array. Starting at the element at
index 3 (i.e. the fourth element) of the array.
<!--l. 1522--><p class="noindent" >The <span 
class="cmtt-10">Length </span>function will return the number of elements in the array. The <span 
class="cmtt-10">Low </span>function on a
dynamic array will always return 0, and the <span 
class="cmtt-10">High </span>function will return the value <span 
class="cmtt-10">Length-1</span>, i.e., the
value of the highest allowed array index.
<!--l. 1528--><p class="noindent" >
<h5 class="subsubsectionHead"><a 
href="refse14.html#QQ2-37-49" id="x37-440003.3.1">Packing and unpacking an array</a></h5>
<!--l. 1529--><p class="noindent" >Arrays can be packed and bitpacked. 2 array types which have the same index type and element
type, but which are differently packed are not assignment compatible.
<!--l. 1533--><p class="noindent" >However, it is possible to convert a normal array to a bitpacked array with the <span 
class="cmtt-10">pack </span>routine. The
reverse operation is possible as well; a bitpacked array can be converted to a normally packed array
using the <span 
class="cmtt-10">unpack </span>routine, as in the following example:
                                                                            

                                                                            
<table 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
Var
&#x00A0;<br />&#x00A0;&#x00A0;foo&#x00A0;:&#x00A0;array&#x00A0;[&#x00A0;&#8217;a&#8217;..&#8217;f&#8217;&#x00A0;]&#x00A0;of&#x00A0;Boolean
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;=&#x00A0;(&#x00A0;false,&#x00A0;false,&#x00A0;true,&#x00A0;false,&#x00A0;false,&#x00A0;false&#x00A0;);
&#x00A0;<br />&#x00A0;&#x00A0;bar&#x00A0;:&#x00A0;packed&#x00A0;array&#x00A0;[&#x00A0;42..47&#x00A0;]&#x00A0;of&#x00A0;Boolean;
&#x00A0;<br />&#x00A0;&#x00A0;baz&#x00A0;:&#x00A0;array&#x00A0;[&#x00A0;&#8217;0&#8217;..&#8217;5&#8217;&#x00A0;]&#x00A0;of&#x00A0;Boolean;
&#x00A0;<br />
&#x00A0;<br />begin
&#x00A0;<br />&#x00A0;&#x00A0;pack(foo,&#8217;a&#8217;,bar);
&#x00A0;<br />&#x00A0;&#x00A0;unpack(bar,baz,&#8217;0&#8217;);
&#x00A0;<br />end.
</div>
</td></tr></table>
<!--l. 1548--><p class="nopar" >More information about the pack and unpack routines can be found in the <span 
class="cmss-10">system </span>unit
reference.
                                                                            

                                                                            
<!--l. 1553--><div class="crosslinks"><p class="noindent">[<a 
href="refsu15.html" >next</a>] [<a 
href="refsu14.html" >front</a>] [<a 
href="refse14.html#refsu14.html" >up</a>] </p></div>
<!--l. 1553--><p class="noindent" ><a 
 id="tailrefsu14.html"></a>    
</body></html> 
